package emailverification

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"

	"time"

	"github.com/lkgiovani/go-boilerplate/internal/domain/email"
	"github.com/lkgiovani/go-boilerplate/internal/domain/user"
	"github.com/lkgiovani/go-boilerplate/internal/errors"
	"github.com/lkgiovani/go-boilerplate/pkg/logger"
	"github.com/lkgiovani/go-boilerplate/pkg/utils"
	"go.uber.org/zap"
)

const (
	// TokenExpirationHours defines how long a token is valid
	TokenExpirationHours = 24
)

// Service handles email verification business logic
type Service struct {
	tokenRepo   Repository
	userRepo    user.UserService
	emailSender email.EmailSender
	frontendURL string
	logger      logger.Logger
}

// NewService creates a new email verification service
func NewService(
	tokenRepo Repository,
	userRepo user.UserService,
	emailSender email.EmailSender,
	frontendURL string,
	logger logger.Logger,
) *Service {
	return &Service{
		tokenRepo:   tokenRepo,
		userRepo:    userRepo,
		emailSender: emailSender,
		frontendURL: frontendURL,
		logger:      logger,
	}
}

// CreateAndSendVerificationToken creates a new verification token and sends the email
func (s *Service) CreateAndSendVerificationToken(ctx context.Context, u *user.User) (*EmailVerificationToken, error) {
	s.logger.Debug("Creating verification token for user", zap.Int64("userId", u.ID))

	// Mark all existing tokens as used
	if err := s.tokenRepo.MarkAllAsUsedByUserID(ctx, u.ID); err != nil {
		s.logger.Error("Failed to mark existing tokens as used", zap.Error(err))
		// Continue anyway, this is not critical
	}

	// Generate secure token
	tokenCode, err := generateSecureToken()
	if err != nil {
		return nil, errors.Errorf(errors.EINTERNAL, "failed to generate token")
	}

	// Create token entity (ID is auto-generated by the database)
	token := &EmailVerificationToken{
		UserID:    u.ID,
		Email:     u.Email,
		Token:     tokenCode,
		ExpiresAt: utils.Now().Add(TokenExpirationHours * time.Hour),
		Used:      false,
	}

	// Save token to database
	if err := s.tokenRepo.Create(ctx, token); err != nil {
		s.logger.Error("Failed to save verification token", zap.Error(err))
		return nil, errors.Errorf(errors.EINTERNAL, "failed to create verification token")
	}

	// Send verification email asynchronously
	go func() {
		sendCtx := context.Background()
		if err := s.sendVerificationEmail(sendCtx, u.Email, tokenCode); err != nil {
			s.logger.Error("Failed to send verification email",
				zap.Int64("userId", u.ID),
				zap.Error(err),
			)
		}
	}()

	s.logger.Info("Verification token created and email queued", zap.Int64("userId", u.ID))
	return token, nil
}

// VerifyToken verifies the email verification token
func (s *Service) VerifyToken(ctx context.Context, tokenCode string) VerifyEmailResult {
	s.logger.Debug("Verifying token")

	// Find token (including used ones to give proper error messages)
	token, err := s.tokenRepo.FindByTokenIncludingUsed(ctx, tokenCode)
	if err != nil {
		s.logger.Warn("Token not found", zap.String("token", truncateToken(tokenCode)))
		return NewFailureResult("Token inválido ou não encontrado")
	}

	// Check if already used
	if token.Used {
		s.logger.Warn("Token already used", zap.Int64("tokenId", token.ID))

		// Check if used more than 1 hour ago
		if token.VerifiedAt != nil && token.VerifiedAt.Before(utils.Now().Add(-1*time.Hour)) {
			return NewFailureResult("Token expirado. Solicite um novo código")
		}

		// Check if user is already verified
		u, errUser := s.userRepo.GetByID(ctx, token.UserID)
		if errUser == nil && u.Metadata.EmailVerified {
			return NewSuccessResult(token.UserID, token.Email, "Email já foi verificado anteriormente")
		}

		return NewFailureResult("Token já foi utilizado")
	}

	// Check if expired
	if token.IsExpired() {
		s.logger.Warn("Token expired", zap.Int64("tokenId", token.ID))
		return NewFailureResult("Token expirado. Solicite um novo código")
	}

	// Mark token as used
	token.MarkAsUsed()
	if err := s.tokenRepo.Save(ctx, token); err != nil {
		s.logger.Error("Failed to mark token as used", zap.Error(err))
		return NewFailureResult("Erro interno ao verificar email")
	}

	// Update user as verified
	u, errGet := s.userRepo.GetByID(ctx, token.UserID)
	if errGet != nil {
		s.logger.Error("Failed to find user", zap.Error(errGet))
		return NewFailureResult("Usuário não encontrado")
	}

	u.Active = true
	u.Metadata.EmailVerified = true
	if err := s.userRepo.Update(ctx, u); err != nil {
		s.logger.Error("Failed to update user verification status", zap.Error(err))
		return NewFailureResult("Erro ao atualizar status de verificação")
	}

	s.logger.Info("Email verified successfully", zap.Int64("userId", token.UserID))
	return NewSuccessResult(token.UserID, token.Email, "Email verificado com sucesso!")
}

// ResendVerification resends verification email for a given email address
func (s *Service) ResendVerification(ctx context.Context, emailAddr string) error {
	s.logger.Debug("Resending verification email", zap.String("email", emailAddr))

	// Find user by email
	u, err := s.userRepo.GetByEmail(ctx, emailAddr)
	if err != nil {
		return errors.Errorf(errors.ENOTFOUND, "Usuário não encontrado")
	}

	// Check if already verified
	if u.Metadata.EmailVerified {
		return errors.Errorf(errors.EINVALID, "Email já verificado")
	}

	// Create and send new token
	_, err = s.CreateAndSendVerificationToken(ctx, u)
	if err != nil {
		return err
	}

	s.logger.Info("Verification email resent", zap.String("email", emailAddr))
	return nil
}

// sendVerificationEmail sends the verification email using the configured email sender
func (s *Service) sendVerificationEmail(ctx context.Context, toEmail, tokenCode string) error {
	verificationURL := s.frontendURL + "/v1/email-verification/verify?token=" + tokenCode

	subject := "Verificação de Email"
	body := fmt.Sprintf(`
		<html>
		<body>
			<h1>Verificação de Email</h1>
			<p>Clique no link abaixo para verificar seu email:</p>
			<a href="%s">Verificar Email</a>
			<p>Ou copie e cole este link no seu navegador:</p>
			<p>%s</p>
			<p>Este link expira em 24 horas.</p>
		</body>
		</html>
	`, verificationURL, verificationURL)

	return s.emailSender.SendEmail(ctx, toEmail, subject, body)
}

// generateSecureToken generates a cryptographically secure random token
func generateSecureToken() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(bytes), nil
}

// truncateToken safely truncates a token for logging purposes
func truncateToken(token string) string {
	if len(token) <= 8 {
		return "***"
	}
	return token[:8] + "..."
}
